{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LeakCanary \ud83d\udc24 LeakCanary is a memory leak detection library for Android. LeakCanary s knowledge of the internals of the Android Framework gives it a unique ability to narrow down the cause of each leak, helping developers dramatically reduce OutOfMemoryError crashes. Get started! Quote \u201cA small leak will sink a great ship.\u201d - Benjamin Franklin","title":"Overview"},{"location":"#leakcanary","text":"LeakCanary is a memory leak detection library for Android. LeakCanary s knowledge of the internals of the Android Framework gives it a unique ability to narrow down the cause of each leak, helping developers dramatically reduce OutOfMemoryError crashes. Get started! Quote \u201cA small leak will sink a great ship.\u201d - Benjamin Franklin","title":"LeakCanary \ud83d\udc24"},{"location":"blog-articles/","text":"Detect memory leaks in your instrumentation tests using LeakCanary 9 ways to avoid memory leaks in Android Your article should be here, please update this list! Any technical level welcome.","title":"Blog Articles"},{"location":"changelog/","text":"Change Log Version 2.0 Alpha 2 (2019-05-21) Thanks for testing the alpha , we re counting on you to help us find bugs and suggest improvements! Check out the new Getting Started instructions and the migration guide . #1040 Import and analyze hprof files from other devices #1344 Computing retained size #1325 New notification showing current count of retained instances #1079 Excluded leaks have been renamed to Won t fix leaks to clarify meaning. #1328 New leaks are called out in the UI. #1327 LeakSentry can be enabled / disabled and is automatically disabled in non debuggable builds. #1173 Experimental: now reporting leaks that only go through weak references (previously reported as no path to instance ) #1339 Readded support for Thread name based exclusions #1312 Fixed bug causing LeakCanary to stop detecting leaks after the app is killed. #1310 #1313 #1314 #1340 #1337 Many API changes #1296 #1293 #1306 #1336 Fixed several crashes. Many thanks to @forrestbice , @Foso , @Goddchen , @marcosholgado , @orionlee , @pyricau , @satoshun , @ZacSweers for the contributions! For more details, see the 2.0-alpha-2 Milestone and the full diff . Version 2.0 Alpha 1 (2019-04-23) New logo , thanks @flickator ! Entirely rewritten to 100% Kotlin Multiple leaks detected in one analysis The heap is dumped when the app goes in the background, or when a minimum of 5 leaks is reached in the foreground. Leak grouping Leaks that share similar causes are grouped in the UI. New screens to see the list of groups and each group. Improved leaktrace strings to highlight leak causes. Leaks can be shared to Stack Overflow New library: LeakSentry . Detects when objects are leaking and triggers LeakCanary Can be used independently in production, for instance to report the number of leaking instances on an OutOfMemoryError crash. New heap parser Uses 90% less memory and 6 times faster than the prior heap parser. Runs in the same process as the app on a low priority thread. No more dependency on Perflib and TroveJ. New dependency on Okio. The old parser is still available as leakcanary-android-perflib but will be removed after alpha. Labelers can add any string content to leak elements 0 code setup, just add the one debug dependency. Simpler configuration options Updated from support library to Android X Many thanks to @BraisGabin , @colinmarsch , @jrodbx , @flickator , @JakeWharton , @pyricau , @WhatsEmo for the contributions! For more details, see the 2.0-alpha-1 Milestone and the full diff . Version 1.6.3 (2019-01-10) #1163 Fixed leaks being incorrectly classified as no leak due to missed GC Roots. #1153 LeakCanary.isInAnalyzerProcess now correctly returns true in the analyzer process prior to any first leak (could be triggered by starting the leak result activity). #1158 Stopped enabling DisplayLeakActivity when not using DisplayLeakService. #1135 Fixed IndexOutOfBoundsException for leak traces of size 1. #1163 Keep no leak heap dumps. Many thanks to @KMaragh , @pyricau , @SebRut for the code contributions! For more details, see the 1.6.3 Milestone and the full diff . Version 1.6.2 (2018-10-16) #1067 Fixed TransactionTooLargeException crash (leak analysis would never complete). #1061 Detection of Fragment view leaks after Fragment#onDestroyView(). #1076 Added the FOREGROUND_SERVICE permission for Android P. #1062 The LeakCanary toast now always shows correctly. It doesn t show if there is no activity in foreground. #1115 Reenabled the DisplayLeakActivity icon on fresh installs. #1100 Added nullability annotations to improve Kotlin support. Updates to excluded leaks ( commits ). Updates to reachability inspectors ( commits ). Many thanks to @fractalwrench , @hzsweers , @Goddchen , @igokoro , @IlyaGulya , @JakeWharton , @javmarina , @jokermonn , @jrodbx , @Parseus , @pyricau , @scottkennedy for the code contributions! Public API changes Subclasses of AbstractAnalysisResultService should now override onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) instead of onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) For more details, see the 1.6.2 Milestone and the full diff . Version 1.6.1 (2018-06-21) #727 Improved leak analysis: LeakCanary now identifies and highlights the potential causes of the leak. #1011 We noticed that computing the retained heap size could take a long time, so it s now optional and off by default. #633 Support for detecting leaks in instrumentation tests ( see the wiki ). #985 Ability to convert leak traces into stack traces for easy remote reporting ( see the wiki ). #983 Support for watching destroyed Fragments. #846 LeakCanary now uses foreground services and displays a notification when the analysis is in progress. This also fixes crashes when analyzing in background on O+. The LeakCanary icon (to start to DisplayLeakActivity) is now hidden by default, and only enabled after the first leak is found. #775 Fixed crash when sharing heap dumps on O+ and added a dependency to the support-core-utils library. #930 DisplayLeakActivity has a responsive icon. #685 Stopped doing IO on main thread in DisplayLeakActivity (fixes StrictMode errors). #999 Updated HAHA to 2.0.4, which uses Trove4j as an external dependency (from jcenter) instead of rebundling it. This is to clarify licences (Apache v2 vs LGPL 2.1). Several bug and crash fixes. Many thanks to @AdityaAnand1 , @alhah , @christxph , @csoon03 , @daqi , @JakeWharton , @jankovd , @jrodbx , @kurtisnelson , @NightlyNexus , @pyricau , @SalvatoreT , @shmuelr , @tokou , @xueqiushi for the code contributions! Note: we made a 1.6 release but quickly followed up with 1.6.1 due to #1058 . Public API changes The installed ref watcher singleton is now available via LeakCanary.installedRefWatcher() AnalysisResult.leakTraceAsFakeException() returns an exception that can be used to report and group leak traces to a tool like Bugsnag or Crashlytics. New InstrumentationLeakDetector and FailTestOnLeakRunListener APIs for detecting leaks in instrumentation tests. New Reachability.Inspector and RefWatcherBuilder.stethoscopeClasses() API to establish reachability and help identify leak causes. Watching activities can be disabled with AndroidRefWatcherBuilder.watchActivities(false) , watching fragments can be disabled with AndroidRefWatcherBuilder.watchFragments(false) LeakCanary.setDisplayLeakActivityDirectoryProvider() is deprecated and replaced with LeakCanary.setLeakDirectoryProvider() New RefWatcherBuilder.computeRetainedHeapSize() API to enable the computing of the retained heap size (off by default). For more details, see the 1.6.1 Milestone and the full diff . Version 1.5.4 (2017-09-22) Restore Java 7 compatibility in leakcanary-watcher Version 1.5.3 (2017-09-17) Fix broken 1.5.2 build Convert leakcanary-watcher from Android library to Java library Disable finish animations in RequestStoragePermissionActivity Corrected README sample for Robolectric tests For more details, see the full diff . Version 1.5.2 (2017-08-09) New excluded leaks Move Leakcanary UI into leak analyzer process Ignore computing retained sizes for bitmaps on O+ Add notification channel for persistent messages on O+ Exclude permission activity from recents menu Updated README and sample for handling Robolectric tests For more details, see the full diff . Version 1.5.1 (2017-04-25) New excluded leaks Fix java.util.MissingFormatArgumentException in DisplayLeakService Separate task affinities for different apps Bump minSdk to 14 Fix HahaHelper for O Preview For more details, see the full diff . Version 1.5 (2016-09-28) New excluded leaks Added LeakCanary.isInAnalyzerProcess() to the no-op jar Fixed several file access issues: No more cleanup on startup, we rotate the heap dump files on every new heap dump. LeakCanary now falls back to the app directory until it can write to the external storage. Leak notifications now each use a distinct notification instead of erasing each other. If LeakCanary can t perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff. Added confirmation dialog when user deletes all leaks. Replace the two LeakCanary configuration methods with a builder that provides more flexibility, see LeakCanary.refWatcher() . For more details, see the full diff . Public API changes New HeapAnalyzer.findTrackedReferences() method for headless analysis when you have no context on what leaked. Added LeakCanary.isInAnalyzerProcess() to the no-op jar Added LeakCanary.refWatcher() which returns an AndroidRefWatcherBuilder that extends RefWatcherBuilder and lets you fully customize the RefWatcher instance. Removed LeakCanary.install(Application, Class) and LeakCanary.androidWatcher(Context, HeapDump.Listener, ExcludedRefs) . Removed R.integer.leak_canary_max_stored_leaks and R.integer.leak_canary_watch_delay_millis , those can now be set via LeakCanary.refWatcher() . Updated the LeakDirectoryProvider API to centralize all file related responsibilities. RefWatcher is now constructed with a WatchExecutor which executes a Retryable , instead of an Executor that executes a Runnable . HeapDumper.NO_DUMP was renamed HeapDumper.RETRY_LATER Version 1.4 (2016-09-11) Fix false negative where GC root is of type android.os.Binder #482 Update HAHA to 2.0.3; clear compiler warnings #563 Correct some mistakes in German translation #516 Don t loop when storage permission denied #422 Remove old references to __ prefixed resources #477 Fix permission crash for DisplayLeakActivity on M #382 Fix NPE when thread name not found in heap dump #417 Add version info to stacktrace #473 Version 1.4-beta2 (2016-03-23) Add reason for ignoring to analysis result #365 . Lower memory usage when parsing heap dumps on M #223 . Fix NPE in LeakCanaryInternals.isInServiceProcess() #449 . New ignored Android SDK leaks #297 , #322 . Use leakcanary-android-no-op in test builds #143 . Fixes to allow LeakCanary to work with ProGuard #398 . Optimize png assets #406 . Fix delete button not working on error views #408 . Add German translation #437 . Version 1.4-beta1 (2016-01-08) Switched to HAHA 2.0.2 with uses Perflib instead of MAT under the hood #219 . This fixes crashes and improves speed a lot. We can now parse Android M heap dumps #267 , although there are still memory issues (see #223 ). Excluded leaks are now reported as well and available in the display leak activity. Added ProGuard configuration for #132 . Many new ignored Android SDK leaks. Added excluded leaks to text report #119 . Added LeakCanary SHA to text report #120 . Added CanaryLog API to replace the logger: #201 . Renamed all resources to begin with leak_canary_ instead of __leak_canary #161 No crash when heap dump fails #226 . Add retained size to leak reports #162 . Public API changes AnalysisResult.failure is now a Throwable instead of an Exception . Main goal is to catch and correctly report OOMs while parsing. Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries. Renamed ExcludedRefs fields. Each ExcludedRef entry can now be ignored entirely or kept only if no other path . Added support for ignoring all fields (static and non static) for a given class. Version 1.3.1 (2015-05-16) Heap dumps and analysis results are now saved on the sd card: #21 . ExcludedRef and AndroidExcludedRefs are customizable: #12 #73 . 7 new ignored Android SDK leaks: #1 #4 #32 #89 #82 #97 . Fixed 3 crashes in LeakCanary: #37 #46 #66 . Fixed StrictMode thread policy violations: #15 . Updated minSdkVersion from 9 to 8 : #57 . Added LeakCanary version name to LeakCanary.leakInfo() : #49 . leakcanary-android-no-op is lighter, it does not depend on leakcanary-watcher anymore, only 2 classes now: #74 . Adding field state details to the text leak trace. A Toast is displayed while the heap dump is in progress to warn that the UI will freeze: #20 . You can customize the toast by providing your own layout named __leak_canary_heap_dump_toast.xml (e.g. you could make it an empty layout). If the analysis fails, the result and heap dump are kept so that it can be reported to LeakCanary: #102 . Update to HAHA 1.3 to fix a 2 crashes #3 46 Public API changes When upgrading from 1.3 to 1.3.1, previously saved heap dumps will not be readable any more, but they won t be removed from the app directory. You should probably uninstall your app. Added android.permission.WRITE_EXTERNAL_STORAGE to leakcanary-android artifact. LeakCanary.androidWatcher() parameter types have changed (+ExcludedRefs). LeakCanary.leakInfo() parameter types have changed (+boolean) ExcludedRef is now serializable and immutable, instances can be created using ExcludedRef.Builder . ExcludedRef is available in HeapDump AndroidExcludedRefs is an enum, you can now pick the leaks you want to ignore in AndroidExcludedRefs by creating an EnumSet and calling AndroidExcludedRefs.createBuilder() . AndroidExcludedRefs.createAppDefaults() AndroidExcludedRefs.createAndroidDefaults() return a ExcludedRef.Builder . ExcludedRef moved from leakcanary-analyzer to leakcanary-watcher Version 1.3 (2015-05-08) Initial release. Dependencies","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-20-alpha-2-2019-05-21","text":"Thanks for testing the alpha , we re counting on you to help us find bugs and suggest improvements! Check out the new Getting Started instructions and the migration guide . #1040 Import and analyze hprof files from other devices #1344 Computing retained size #1325 New notification showing current count of retained instances #1079 Excluded leaks have been renamed to Won t fix leaks to clarify meaning. #1328 New leaks are called out in the UI. #1327 LeakSentry can be enabled / disabled and is automatically disabled in non debuggable builds. #1173 Experimental: now reporting leaks that only go through weak references (previously reported as no path to instance ) #1339 Readded support for Thread name based exclusions #1312 Fixed bug causing LeakCanary to stop detecting leaks after the app is killed. #1310 #1313 #1314 #1340 #1337 Many API changes #1296 #1293 #1306 #1336 Fixed several crashes. Many thanks to @forrestbice , @Foso , @Goddchen , @marcosholgado , @orionlee , @pyricau , @satoshun , @ZacSweers for the contributions! For more details, see the 2.0-alpha-2 Milestone and the full diff .","title":"Version 2.0 Alpha 2 (2019-05-21)"},{"location":"changelog/#version-20-alpha-1-2019-04-23","text":"New logo , thanks @flickator ! Entirely rewritten to 100% Kotlin Multiple leaks detected in one analysis The heap is dumped when the app goes in the background, or when a minimum of 5 leaks is reached in the foreground. Leak grouping Leaks that share similar causes are grouped in the UI. New screens to see the list of groups and each group. Improved leaktrace strings to highlight leak causes. Leaks can be shared to Stack Overflow New library: LeakSentry . Detects when objects are leaking and triggers LeakCanary Can be used independently in production, for instance to report the number of leaking instances on an OutOfMemoryError crash. New heap parser Uses 90% less memory and 6 times faster than the prior heap parser. Runs in the same process as the app on a low priority thread. No more dependency on Perflib and TroveJ. New dependency on Okio. The old parser is still available as leakcanary-android-perflib but will be removed after alpha. Labelers can add any string content to leak elements 0 code setup, just add the one debug dependency. Simpler configuration options Updated from support library to Android X Many thanks to @BraisGabin , @colinmarsch , @jrodbx , @flickator , @JakeWharton , @pyricau , @WhatsEmo for the contributions! For more details, see the 2.0-alpha-1 Milestone and the full diff .","title":"Version 2.0 Alpha 1 (2019-04-23)"},{"location":"changelog/#version-163-2019-01-10","text":"#1163 Fixed leaks being incorrectly classified as no leak due to missed GC Roots. #1153 LeakCanary.isInAnalyzerProcess now correctly returns true in the analyzer process prior to any first leak (could be triggered by starting the leak result activity). #1158 Stopped enabling DisplayLeakActivity when not using DisplayLeakService. #1135 Fixed IndexOutOfBoundsException for leak traces of size 1. #1163 Keep no leak heap dumps. Many thanks to @KMaragh , @pyricau , @SebRut for the code contributions! For more details, see the 1.6.3 Milestone and the full diff .","title":"Version 1.6.3 (2019-01-10)"},{"location":"changelog/#version-162-2018-10-16","text":"#1067 Fixed TransactionTooLargeException crash (leak analysis would never complete). #1061 Detection of Fragment view leaks after Fragment#onDestroyView(). #1076 Added the FOREGROUND_SERVICE permission for Android P. #1062 The LeakCanary toast now always shows correctly. It doesn t show if there is no activity in foreground. #1115 Reenabled the DisplayLeakActivity icon on fresh installs. #1100 Added nullability annotations to improve Kotlin support. Updates to excluded leaks ( commits ). Updates to reachability inspectors ( commits ). Many thanks to @fractalwrench , @hzsweers , @Goddchen , @igokoro , @IlyaGulya , @JakeWharton , @javmarina , @jokermonn , @jrodbx , @Parseus , @pyricau , @scottkennedy for the code contributions!","title":"Version 1.6.2 (2018-10-16)"},{"location":"changelog/#public-api-changes","text":"Subclasses of AbstractAnalysisResultService should now override onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) instead of onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) For more details, see the 1.6.2 Milestone and the full diff .","title":"Public API changes"},{"location":"changelog/#version-161-2018-06-21","text":"#727 Improved leak analysis: LeakCanary now identifies and highlights the potential causes of the leak. #1011 We noticed that computing the retained heap size could take a long time, so it s now optional and off by default. #633 Support for detecting leaks in instrumentation tests ( see the wiki ). #985 Ability to convert leak traces into stack traces for easy remote reporting ( see the wiki ). #983 Support for watching destroyed Fragments. #846 LeakCanary now uses foreground services and displays a notification when the analysis is in progress. This also fixes crashes when analyzing in background on O+. The LeakCanary icon (to start to DisplayLeakActivity) is now hidden by default, and only enabled after the first leak is found. #775 Fixed crash when sharing heap dumps on O+ and added a dependency to the support-core-utils library. #930 DisplayLeakActivity has a responsive icon. #685 Stopped doing IO on main thread in DisplayLeakActivity (fixes StrictMode errors). #999 Updated HAHA to 2.0.4, which uses Trove4j as an external dependency (from jcenter) instead of rebundling it. This is to clarify licences (Apache v2 vs LGPL 2.1). Several bug and crash fixes. Many thanks to @AdityaAnand1 , @alhah , @christxph , @csoon03 , @daqi , @JakeWharton , @jankovd , @jrodbx , @kurtisnelson , @NightlyNexus , @pyricau , @SalvatoreT , @shmuelr , @tokou , @xueqiushi for the code contributions! Note: we made a 1.6 release but quickly followed up with 1.6.1 due to #1058 .","title":"Version 1.6.1 (2018-06-21)"},{"location":"changelog/#public-api-changes_1","text":"The installed ref watcher singleton is now available via LeakCanary.installedRefWatcher() AnalysisResult.leakTraceAsFakeException() returns an exception that can be used to report and group leak traces to a tool like Bugsnag or Crashlytics. New InstrumentationLeakDetector and FailTestOnLeakRunListener APIs for detecting leaks in instrumentation tests. New Reachability.Inspector and RefWatcherBuilder.stethoscopeClasses() API to establish reachability and help identify leak causes. Watching activities can be disabled with AndroidRefWatcherBuilder.watchActivities(false) , watching fragments can be disabled with AndroidRefWatcherBuilder.watchFragments(false) LeakCanary.setDisplayLeakActivityDirectoryProvider() is deprecated and replaced with LeakCanary.setLeakDirectoryProvider() New RefWatcherBuilder.computeRetainedHeapSize() API to enable the computing of the retained heap size (off by default). For more details, see the 1.6.1 Milestone and the full diff .","title":"Public API changes"},{"location":"changelog/#version-154-2017-09-22","text":"Restore Java 7 compatibility in leakcanary-watcher","title":"Version 1.5.4 (2017-09-22)"},{"location":"changelog/#version-153-2017-09-17","text":"Fix broken 1.5.2 build Convert leakcanary-watcher from Android library to Java library Disable finish animations in RequestStoragePermissionActivity Corrected README sample for Robolectric tests For more details, see the full diff .","title":"Version 1.5.3 (2017-09-17)"},{"location":"changelog/#version-152-2017-08-09","text":"New excluded leaks Move Leakcanary UI into leak analyzer process Ignore computing retained sizes for bitmaps on O+ Add notification channel for persistent messages on O+ Exclude permission activity from recents menu Updated README and sample for handling Robolectric tests For more details, see the full diff .","title":"Version 1.5.2 (2017-08-09)"},{"location":"changelog/#version-151-2017-04-25","text":"New excluded leaks Fix java.util.MissingFormatArgumentException in DisplayLeakService Separate task affinities for different apps Bump minSdk to 14 Fix HahaHelper for O Preview For more details, see the full diff .","title":"Version 1.5.1 (2017-04-25)"},{"location":"changelog/#version-15-2016-09-28","text":"New excluded leaks Added LeakCanary.isInAnalyzerProcess() to the no-op jar Fixed several file access issues: No more cleanup on startup, we rotate the heap dump files on every new heap dump. LeakCanary now falls back to the app directory until it can write to the external storage. Leak notifications now each use a distinct notification instead of erasing each other. If LeakCanary can t perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff. Added confirmation dialog when user deletes all leaks. Replace the two LeakCanary configuration methods with a builder that provides more flexibility, see LeakCanary.refWatcher() . For more details, see the full diff .","title":"Version 1.5 (2016-09-28)"},{"location":"changelog/#public-api-changes_2","text":"New HeapAnalyzer.findTrackedReferences() method for headless analysis when you have no context on what leaked. Added LeakCanary.isInAnalyzerProcess() to the no-op jar Added LeakCanary.refWatcher() which returns an AndroidRefWatcherBuilder that extends RefWatcherBuilder and lets you fully customize the RefWatcher instance. Removed LeakCanary.install(Application, Class) and LeakCanary.androidWatcher(Context, HeapDump.Listener, ExcludedRefs) . Removed R.integer.leak_canary_max_stored_leaks and R.integer.leak_canary_watch_delay_millis , those can now be set via LeakCanary.refWatcher() . Updated the LeakDirectoryProvider API to centralize all file related responsibilities. RefWatcher is now constructed with a WatchExecutor which executes a Retryable , instead of an Executor that executes a Runnable . HeapDumper.NO_DUMP was renamed HeapDumper.RETRY_LATER","title":"Public API changes"},{"location":"changelog/#version-14-2016-09-11","text":"Fix false negative where GC root is of type android.os.Binder #482 Update HAHA to 2.0.3; clear compiler warnings #563 Correct some mistakes in German translation #516 Don t loop when storage permission denied #422 Remove old references to __ prefixed resources #477 Fix permission crash for DisplayLeakActivity on M #382 Fix NPE when thread name not found in heap dump #417 Add version info to stacktrace #473","title":"Version 1.4 (2016-09-11)"},{"location":"changelog/#version-14-beta2-2016-03-23","text":"Add reason for ignoring to analysis result #365 . Lower memory usage when parsing heap dumps on M #223 . Fix NPE in LeakCanaryInternals.isInServiceProcess() #449 . New ignored Android SDK leaks #297 , #322 . Use leakcanary-android-no-op in test builds #143 . Fixes to allow LeakCanary to work with ProGuard #398 . Optimize png assets #406 . Fix delete button not working on error views #408 . Add German translation #437 .","title":"Version 1.4-beta2 (2016-03-23)"},{"location":"changelog/#version-14-beta1-2016-01-08","text":"Switched to HAHA 2.0.2 with uses Perflib instead of MAT under the hood #219 . This fixes crashes and improves speed a lot. We can now parse Android M heap dumps #267 , although there are still memory issues (see #223 ). Excluded leaks are now reported as well and available in the display leak activity. Added ProGuard configuration for #132 . Many new ignored Android SDK leaks. Added excluded leaks to text report #119 . Added LeakCanary SHA to text report #120 . Added CanaryLog API to replace the logger: #201 . Renamed all resources to begin with leak_canary_ instead of __leak_canary #161 No crash when heap dump fails #226 . Add retained size to leak reports #162 .","title":"Version 1.4-beta1 (2016-01-08)"},{"location":"changelog/#public-api-changes_3","text":"AnalysisResult.failure is now a Throwable instead of an Exception . Main goal is to catch and correctly report OOMs while parsing. Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries. Renamed ExcludedRefs fields. Each ExcludedRef entry can now be ignored entirely or kept only if no other path . Added support for ignoring all fields (static and non static) for a given class.","title":"Public API changes"},{"location":"changelog/#version-131-2015-05-16","text":"Heap dumps and analysis results are now saved on the sd card: #21 . ExcludedRef and AndroidExcludedRefs are customizable: #12 #73 . 7 new ignored Android SDK leaks: #1 #4 #32 #89 #82 #97 . Fixed 3 crashes in LeakCanary: #37 #46 #66 . Fixed StrictMode thread policy violations: #15 . Updated minSdkVersion from 9 to 8 : #57 . Added LeakCanary version name to LeakCanary.leakInfo() : #49 . leakcanary-android-no-op is lighter, it does not depend on leakcanary-watcher anymore, only 2 classes now: #74 . Adding field state details to the text leak trace. A Toast is displayed while the heap dump is in progress to warn that the UI will freeze: #20 . You can customize the toast by providing your own layout named __leak_canary_heap_dump_toast.xml (e.g. you could make it an empty layout). If the analysis fails, the result and heap dump are kept so that it can be reported to LeakCanary: #102 . Update to HAHA 1.3 to fix a 2 crashes #3 46","title":"Version 1.3.1 (2015-05-16)"},{"location":"changelog/#public-api-changes_4","text":"When upgrading from 1.3 to 1.3.1, previously saved heap dumps will not be readable any more, but they won t be removed from the app directory. You should probably uninstall your app. Added android.permission.WRITE_EXTERNAL_STORAGE to leakcanary-android artifact. LeakCanary.androidWatcher() parameter types have changed (+ExcludedRefs). LeakCanary.leakInfo() parameter types have changed (+boolean) ExcludedRef is now serializable and immutable, instances can be created using ExcludedRef.Builder . ExcludedRef is available in HeapDump AndroidExcludedRefs is an enum, you can now pick the leaks you want to ignore in AndroidExcludedRefs by creating an EnumSet and calling AndroidExcludedRefs.createBuilder() . AndroidExcludedRefs.createAppDefaults() AndroidExcludedRefs.createAndroidDefaults() return a ExcludedRef.Builder . ExcludedRef moved from leakcanary-analyzer to leakcanary-watcher","title":"Public API changes"},{"location":"changelog/#version-13-2015-05-08","text":"Initial release.","title":"Version 1.3 (2015-05-08)"},{"location":"changelog/#dependencies","text":"","title":"Dependencies"},{"location":"code_of_conduct/","text":"Open Source Code of Conduct At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"code_of_conduct/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"code_of_conduct/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"code_of_conduct/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"code_of_conduct/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"code_of_conduct/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"contributing/","text":"Contributing If you would like to contribute code to LeakCanary you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running ./gradlew build .","title":"Contributing"},{"location":"contributing/#contributing","text":"If you would like to contribute code to LeakCanary you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running ./gradlew build .","title":"Contributing"},{"location":"faq/","text":"FAQ Can a leak be caused by the Android SDK? Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: AndroidExcludedRefs.kt . If you find a new one, please create an issue and follow these steps: Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions android/platform_frameworks_base . Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed. If it s still happening, build a simple repro case File an issue on b.android.com with the leak trace and the repro case Create a PR in LeakCanary to update AndroidExcludedRefs.kt . Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it. How do I share a leak trace? Go to the leak screen, click the overflow menu and select Share Info . You can also find the leak trace in Logcat. How can I dig beyond the leak trace? Sometimes the leak trace isn t enough and you need to dig into a heap dump with MAT or YourKit . Go to a heap analysis screen, click the overflow menu and select Share Heap Dump . Here s how you can find the leaking instance in the heap dump: Look for all instances of leakcanary.KeyedWeakReference For each of these, look at the key field. Find the KeyedWeakReference that has a key field equal to the reference key reported by LeakCanary. The referent field of that KeyedWeakReference is your leaking object. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references). How many methods does LeakCanary add? 0 . LeakCanary is a debug only library. How do I use the SNAPSHOT version? Update your dependencies to the latest SNAPSHOT (see build.gradle ): dependencies { debugCompile com.squareup.leakcanary:leakcanary-android:2.0-alpha-3-SNAPSHOT } Add Sonatype s snapshots repository: repositories { mavenCentral() maven { url https://oss.sonatype.org/content/repositories/snapshots/ } } Status of the snapshot build: Who s behind LeakCanary? LeakCanary was created and open sourced by @pyricau , with many contributions from the community. Why is it called LeakCanary? The name LeakCanary is a reference to the expression canary in a coal mine , because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to @edenman for suggesting it! Who made the logo? @pyricau quickly made the first version of the logo. It was based on cliparts from Android Asset Studio , mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary. @romainguy turned the ugly logo into a nice vector asset . @flickator designed a much nicer logo for LeakCanary 2.0!","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#can-a-leak-be-caused-by-the-android-sdk","text":"Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: AndroidExcludedRefs.kt . If you find a new one, please create an issue and follow these steps: Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions android/platform_frameworks_base . Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed. If it s still happening, build a simple repro case File an issue on b.android.com with the leak trace and the repro case Create a PR in LeakCanary to update AndroidExcludedRefs.kt . Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.","title":"Can a leak be caused by the Android SDK?"},{"location":"faq/#how-do-i-share-a-leak-trace","text":"Go to the leak screen, click the overflow menu and select Share Info . You can also find the leak trace in Logcat.","title":"How do I share a leak trace?"},{"location":"faq/#how-can-i-dig-beyond-the-leak-trace","text":"Sometimes the leak trace isn t enough and you need to dig into a heap dump with MAT or YourKit . Go to a heap analysis screen, click the overflow menu and select Share Heap Dump . Here s how you can find the leaking instance in the heap dump: Look for all instances of leakcanary.KeyedWeakReference For each of these, look at the key field. Find the KeyedWeakReference that has a key field equal to the reference key reported by LeakCanary. The referent field of that KeyedWeakReference is your leaking object. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).","title":"How can I dig beyond the leak trace?"},{"location":"faq/#how-many-methods-does-leakcanary-add","text":"0 . LeakCanary is a debug only library.","title":"How many methods does LeakCanary add?"},{"location":"faq/#how-do-i-use-the-snapshot-version","text":"Update your dependencies to the latest SNAPSHOT (see build.gradle ): dependencies { debugCompile com.squareup.leakcanary:leakcanary-android:2.0-alpha-3-SNAPSHOT } Add Sonatype s snapshots repository: repositories { mavenCentral() maven { url https://oss.sonatype.org/content/repositories/snapshots/ } } Status of the snapshot build:","title":"How do I use the SNAPSHOT version?"},{"location":"faq/#whos-behind-leakcanary","text":"LeakCanary was created and open sourced by @pyricau , with many contributions from the community.","title":"Who's behind LeakCanary?"},{"location":"faq/#why-is-it-called-leakcanary","text":"The name LeakCanary is a reference to the expression canary in a coal mine , because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to @edenman for suggesting it!","title":"Why is it called LeakCanary?"},{"location":"faq/#who-made-the-logo","text":"@pyricau quickly made the first version of the logo. It was based on cliparts from Android Asset Studio , mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary. @romainguy turned the ugly logo into a nice vector asset . @flickator designed a much nicer logo for LeakCanary 2.0!","title":"Who made the logo?"},{"location":"fundamentals/","text":"Fundamentals What is a memory leak? In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash. For example, an Android activity instance is no longer needed after its onDestroy() method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected. Why should I use LeakCanary? Memory leaks are very common in Android apps. OutOfMemoryError (OOM) is the top crash for most apps on the play store, however that s usually not counted correctly. When memory is low the OOM can be thrown from anywhere in your code, which means every OOM has a different stacktrace and they re counted as different crashes. When we first enabled LeakCanary in the Square Point Of Sale app, we were able to find and fix several leaks and reduced the OutOfMemoryError crash rate by 94% . How does LeakCanary work? Detecting retained instances The foundation of LeakCanary is a library called LeakSentry. LeakSentry hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to a RefWatcher , which holds weak references to them. You can also watch any instance that is no longer needed, e.g. a detached view, a destroyed presenter, etc. If the weak references aren t cleared after waiting 5 seconds and running the garbage collector, the watched instances are considered retained , and potentially leaking. Dumping the heap When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a .hprof file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise. Analyzing the heap LeakCanary parses the .hprof file and finds the chain of references that prevents retained instances from being garbage collected: the leak trace . Leak trace is another name for the shortest strong reference path from garbage collection roots to retained instances . Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below How do I fix a memory leak? ). Grouping leaks Using the leak status information, LeakCanary narrows down the reference chain to a sub chain of possible leak causes, and displays the result. Leaks that have the same causal chain are considered to be the same leak, so leaks are grouped by identical sub chain. How do I fix a memory leak? For each leaking instance, LeakCanary computes a leak trace and displays it in its UI: The leak trace is also logged to Logcat: \u252c \u251c\u2500 leakcanary.internal.InternalLeakCanary \u2502 Leaking: NO (it s a GC root and a class is never leaking) \u2502 \u2193 static InternalLeakCanary.application \u251c\u2500 com.example.leakcanary.ExampleApplication \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList \u2502 Leaking: UNKNOWN \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] \u2502 Leaking: UNKNOWN \u2502 \u2193 array Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView \u2502 Leaking: YES (View detached and has parent) \u2502 View#mAttachInfo is null (view detached) \u2502 View#mParent is set \u2502 View.mWindowAttachCount=1 \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity \u200b Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true) Objects and references \u251c\u2500 android.widget.TextView Each node in the leak trace is a Java object and is either a class, an object array or an instance. \u2502 \u2193 TextView.mContext Going down, each node has a reference to the next node. In the UI, that reference is in purple . In the Logcat representation, the reference is on the line that starts with a down arrow. GC Root \u252c \u251c\u2500 leakcanary.internal.InternalLeakCanary \u2502 Leaking: NO (it s a GC root and a class is never leaking) At the top of the leak trace is a garbage-collection (GC) root. GC roots are special objects that are always reachable. There are four kinds of GC roots worth mentioning: Local variables , which belong to the stack of a thread. Instances of active Java threads . Classes , which never unload on Android. Native references , which are controlled by native code. Leaking instance \u2570\u2192 com.example.leakcanary.MainActivity \u200b Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true) At the bottom of the leak trace is the leaking instance. This instance was passed to RefWatcher.watch() to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary. Chain of references ... \u2502 \u2193 static InternalLeakCanary.application ... \u2502 \u2193 ExampleApplication.leakedViews ... \u2502 \u2193 ArrayList.elementData ... \u2502 \u2193 array Object[].[0] ... \u2502 \u2193 TextView.mContext ... The chain of references from the GC root to the leaking instance is what is preventing the leaking instance from being garbage collected. If you can identify the reference that should not exist at that point in time, then you can figure out why it s incorrectly still set and then fix the memory leak. Heuristics and labels \u251c\u2500 android.widget.TextView \u2502 Leaking: YES (View detached and has parent) LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has View#mAttachInfo = null and mParent != null then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you ll see Leaking: YES / NO / UNKNOWN with an explanation in parenthesis. You can customize this behavior and add your own heuristics. \u2502 View#mAttachInfo is null (view detached) \u2502 View#mParent is set \u2502 View.mWindowAttachCount=1 LeakCanary can also surface extra information about the state of a node, e.g. View.mWindowAttachCount=1 . You can add your own labels. Narrowing down the cause of a leak \u252c \u251c\u2500 leakcanary.internal.InternalLeakCanary \u2502 Leaking: NO (it s a GC root and a class is never leaking) \u2502 \u2193 static InternalLeakCanary.application \u251c\u2500 com.example.leakcanary.ExampleApplication \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList \u2502 Leaking: UNKNOWN \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] \u2502 Leaking: UNKNOWN \u2502 \u2193 array Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView \u2502 Leaking: YES (View detached and has parent) \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity \u200b Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true) If a node is not leaking, then any prior reference that points to it is not the source of the leak, and also not leaking. Similarly, if a node is leaking then any node down the leak trace is also leaking. From that, we can deduce that the leak is caused by a reference that is after the last Leaking: NO and before the first Leaking: YES . LeakCanary highlights those references with a red underline in the UI, or a ~~~~ underline in the Logcat representation. These highlighted references are the only possible causes of the leak . These are the references you should spend time investigating. In this example, the last Leaking: NO is on com.example.leakcanary.ExampleApplication and the first Leaking: YES is on android.widget.TextView , so the leak is caused by one of the 3 references in between: ... \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ ... \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ ... \u2502 \u2193 array Object[].[0] \u2502 ~~~ ... Looking at the source , we can see that ExampleApplication has a list field: open class ExampleApplication : Application() { val leakedViews = mutableListOf View () } It s unlikely that there s a bug in the ArrayList implementation itself, so the leak happens because we re adding views to ExampleApplication.leakedViews . If we stop doing that, we ve fixed the leak! Asking for help with a leak If you cannot figure out a leak, please do not file an issue . Instead, create a Stack Overflow question using the leakcanary tag. LeakCanary artifacts LeakCanary is released as several distinct libraries: LeakSentry Detects retained instances. Suitable for release builds. Artifact id: com.squareup.leakcanary:leaksentry . LeakCanary Dumps the heap and analyzes it. Currently only suitable for debug builds. Depends on LeakSentry. Artifact id: com.squareup.leakcanary:leakcanary-android . LeakCanary for Instrumentation tests Fails tests if a leak is detected Only suitable for Instrumentation tests Configures LeakCanary to wait for the end of tests before dumping the heap. Artifact id: com.squareup.leakcanary:leakcanary-android-instrumentation . See Running LeakCanary in instrumentation tests","title":"Fundamentals"},{"location":"fundamentals/#fundamentals","text":"","title":"Fundamentals"},{"location":"fundamentals/#what-is-a-memory-leak","text":"In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash. For example, an Android activity instance is no longer needed after its onDestroy() method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected.","title":"What is a memory leak?"},{"location":"fundamentals/#why-should-i-use-leakcanary","text":"Memory leaks are very common in Android apps. OutOfMemoryError (OOM) is the top crash for most apps on the play store, however that s usually not counted correctly. When memory is low the OOM can be thrown from anywhere in your code, which means every OOM has a different stacktrace and they re counted as different crashes. When we first enabled LeakCanary in the Square Point Of Sale app, we were able to find and fix several leaks and reduced the OutOfMemoryError crash rate by 94% .","title":"Why should I use LeakCanary?"},{"location":"fundamentals/#how-does-leakcanary-work","text":"","title":"How does LeakCanary work?"},{"location":"fundamentals/#detecting-retained-instances","text":"The foundation of LeakCanary is a library called LeakSentry. LeakSentry hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to a RefWatcher , which holds weak references to them. You can also watch any instance that is no longer needed, e.g. a detached view, a destroyed presenter, etc. If the weak references aren t cleared after waiting 5 seconds and running the garbage collector, the watched instances are considered retained , and potentially leaking.","title":"Detecting retained instances"},{"location":"fundamentals/#dumping-the-heap","text":"When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a .hprof file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.","title":"Dumping the heap"},{"location":"fundamentals/#analyzing-the-heap","text":"LeakCanary parses the .hprof file and finds the chain of references that prevents retained instances from being garbage collected: the leak trace . Leak trace is another name for the shortest strong reference path from garbage collection roots to retained instances . Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below How do I fix a memory leak? ).","title":"Analyzing the heap"},{"location":"fundamentals/#grouping-leaks","text":"Using the leak status information, LeakCanary narrows down the reference chain to a sub chain of possible leak causes, and displays the result. Leaks that have the same causal chain are considered to be the same leak, so leaks are grouped by identical sub chain.","title":"Grouping leaks"},{"location":"fundamentals/#how-do-i-fix-a-memory-leak","text":"For each leaking instance, LeakCanary computes a leak trace and displays it in its UI: The leak trace is also logged to Logcat: \u252c \u251c\u2500 leakcanary.internal.InternalLeakCanary \u2502 Leaking: NO (it s a GC root and a class is never leaking) \u2502 \u2193 static InternalLeakCanary.application \u251c\u2500 com.example.leakcanary.ExampleApplication \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList \u2502 Leaking: UNKNOWN \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] \u2502 Leaking: UNKNOWN \u2502 \u2193 array Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView \u2502 Leaking: YES (View detached and has parent) \u2502 View#mAttachInfo is null (view detached) \u2502 View#mParent is set \u2502 View.mWindowAttachCount=1 \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity \u200b Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true)","title":"How do I fix a memory leak?"},{"location":"fundamentals/#objects-and-references","text":"\u251c\u2500 android.widget.TextView Each node in the leak trace is a Java object and is either a class, an object array or an instance. \u2502 \u2193 TextView.mContext Going down, each node has a reference to the next node. In the UI, that reference is in purple . In the Logcat representation, the reference is on the line that starts with a down arrow.","title":"Objects and references"},{"location":"fundamentals/#gc-root","text":"\u252c \u251c\u2500 leakcanary.internal.InternalLeakCanary \u2502 Leaking: NO (it s a GC root and a class is never leaking) At the top of the leak trace is a garbage-collection (GC) root. GC roots are special objects that are always reachable. There are four kinds of GC roots worth mentioning: Local variables , which belong to the stack of a thread. Instances of active Java threads . Classes , which never unload on Android. Native references , which are controlled by native code.","title":"GC Root"},{"location":"fundamentals/#leaking-instance","text":"\u2570\u2192 com.example.leakcanary.MainActivity \u200b Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true) At the bottom of the leak trace is the leaking instance. This instance was passed to RefWatcher.watch() to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary.","title":"Leaking instance"},{"location":"fundamentals/#chain-of-references","text":"... \u2502 \u2193 static InternalLeakCanary.application ... \u2502 \u2193 ExampleApplication.leakedViews ... \u2502 \u2193 ArrayList.elementData ... \u2502 \u2193 array Object[].[0] ... \u2502 \u2193 TextView.mContext ... The chain of references from the GC root to the leaking instance is what is preventing the leaking instance from being garbage collected. If you can identify the reference that should not exist at that point in time, then you can figure out why it s incorrectly still set and then fix the memory leak.","title":"Chain of references"},{"location":"fundamentals/#heuristics-and-labels","text":"\u251c\u2500 android.widget.TextView \u2502 Leaking: YES (View detached and has parent) LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has View#mAttachInfo = null and mParent != null then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you ll see Leaking: YES / NO / UNKNOWN with an explanation in parenthesis. You can customize this behavior and add your own heuristics. \u2502 View#mAttachInfo is null (view detached) \u2502 View#mParent is set \u2502 View.mWindowAttachCount=1 LeakCanary can also surface extra information about the state of a node, e.g. View.mWindowAttachCount=1 . You can add your own labels.","title":"Heuristics and labels"},{"location":"fundamentals/#narrowing-down-the-cause-of-a-leak","text":"\u252c \u251c\u2500 leakcanary.internal.InternalLeakCanary \u2502 Leaking: NO (it s a GC root and a class is never leaking) \u2502 \u2193 static InternalLeakCanary.application \u251c\u2500 com.example.leakcanary.ExampleApplication \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList \u2502 Leaking: UNKNOWN \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] \u2502 Leaking: UNKNOWN \u2502 \u2193 array Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView \u2502 Leaking: YES (View detached and has parent) \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity \u200b Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true) If a node is not leaking, then any prior reference that points to it is not the source of the leak, and also not leaking. Similarly, if a node is leaking then any node down the leak trace is also leaking. From that, we can deduce that the leak is caused by a reference that is after the last Leaking: NO and before the first Leaking: YES . LeakCanary highlights those references with a red underline in the UI, or a ~~~~ underline in the Logcat representation. These highlighted references are the only possible causes of the leak . These are the references you should spend time investigating. In this example, the last Leaking: NO is on com.example.leakcanary.ExampleApplication and the first Leaking: YES is on android.widget.TextView , so the leak is caused by one of the 3 references in between: ... \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ ... \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ ... \u2502 \u2193 array Object[].[0] \u2502 ~~~ ... Looking at the source , we can see that ExampleApplication has a list field: open class ExampleApplication : Application() { val leakedViews = mutableListOf View () } It s unlikely that there s a bug in the ArrayList implementation itself, so the leak happens because we re adding views to ExampleApplication.leakedViews . If we stop doing that, we ve fixed the leak!","title":"Narrowing down the cause of a leak"},{"location":"fundamentals/#asking-for-help-with-a-leak","text":"If you cannot figure out a leak, please do not file an issue . Instead, create a Stack Overflow question using the leakcanary tag.","title":"Asking for help with a leak"},{"location":"fundamentals/#leakcanary-artifacts","text":"LeakCanary is released as several distinct libraries: LeakSentry Detects retained instances. Suitable for release builds. Artifact id: com.squareup.leakcanary:leaksentry . LeakCanary Dumps the heap and analyzes it. Currently only suitable for debug builds. Depends on LeakSentry. Artifact id: com.squareup.leakcanary:leakcanary-android . LeakCanary for Instrumentation tests Fails tests if a leak is detected Only suitable for Instrumentation tests Configures LeakCanary to wait for the end of tests before dumping the heap. Artifact id: com.squareup.leakcanary:leakcanary-android-instrumentation . See Running LeakCanary in instrumentation tests","title":"LeakCanary artifacts"},{"location":"getting_started/","text":"Getting started Add LeakCanary to build.gradle : dependencies { // debugImplementation because LeakCanary should only run in debug builds. debugImplementation com.squareup.leakcanary:leakcanary-android:2.0-alpha-2 } That s it, there is no code change needed! LeakCanary will automatically show a notification when a memory leak is detected in debug builds. What s next? Learn the Fundamentals Try the code recipes Read the FAQ","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"Add LeakCanary to build.gradle : dependencies { // debugImplementation because LeakCanary should only run in debug builds. debugImplementation com.squareup.leakcanary:leakcanary-android:2.0-alpha-2 } That s it, there is no code change needed! LeakCanary will automatically show a notification when a memory leak is detected in debug builds. What s next? Learn the Fundamentals Try the code recipes Read the FAQ","title":"Getting started"},{"location":"recipes/","text":"Code Recipes If you think a recipe might be missing or you re not sure that what you re trying to achieve is possible with the current APIs, please file an issue . Your feedback help us make LeakCanary better for the entire community. Configuring LeakSentry LeakSentry can be configured by replacing LeakSentry.config : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakSentry . config = LeakSentry . config . copy ( watchFragmentViews = false ) } } Configuring LeakCanary LeakCanary can be configured by replacing LeakCanary.config : disableLeakCanaryButton . setOnClickListener { LeakCanary . config = LeakCanary . config . copy ( dumpHeap = false ) } Watching objects with a lifecycle In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use LeakSentry.refWatcher to watch instances that should be garbage collected: class MyService : Service { // ... override fun onDestroy () { super . onDestroy () LeakSentry . refWatcher . watch ( this ) } } Counting retained instances in production com.squareup.leakcanary:leakcanary-android should only be used in debug builds. It depends on com.squareup.leakcanary:leaksentry which you can use in production to track and count retained instances. In your build.gradle : dependencies { implementation com.squareup.leakcanary:leaksentry:2.0-alpha-2 } In your leak reporting code: val retainedInstanceCount = LeakSentry . refWatcher . retainedKeys . size Running LeakCanary in instrumentation tests Add the leakcanary-android-instrumentation dependency to your instrumentation tests: androidTestImplementation com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion} Add the dedicated run listener to defaultConfig in your build.gradle : android { defaultConfig { // ... testInstrumentationRunner android.support.test.runner.AndroidJUnitRunner testInstrumentationRunnerArgument listener , leakcanary.FailTestOnLeakRunListener } } Run the instrumentation tests: ./gradlew leakcanary-sample:connectedCheck You can extend FailTestOnLeakRunListener to customize the behavior. Icon and label The activity that displays leaks comes with a default icon and label, which you can change by providing R.mipmap.leak_canary_icon and R.string.leak_canary_display_activity_label in your app: res/ mipmap-hdpi/ leak_canary_icon.png mipmap-mdpi/ leak_canary_icon.png mipmap-xhdpi/ leak_canary_icon.png mipmap-xxhdpi/ leak_canary_icon.png mipmap-xxxhdpi/ leak_canary_icon.png mipmap-anydpi-v26/ leak_canary_icon.xml ?xml version= 1.0 encoding= utf-8 ? resources string name= leak_canary_display_activity_label MyLeaks /string /resources Uploading to a server You can change the default behavior to upload the analysis result to a server of your choosing. Create a custom AnalysisResultListener that delegates to the default: class LeakUploader : AnalysisResultListener { override fun invoke ( application : Application , heapAnalysis : HeapAnalysis ) { TODO ( Upload heap analysis to server ) // Delegate to default behavior (notification and saving result) DefaultAnalysisResultListener ( application , heapAnalysis ) } } Set analysisResultListener on the LeakCanary config: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( analysisResultListener = LeakUploader ()) } } Identifying 3 rd party leaks as won t fix Set exclusionsFactory on the LeakCanary config to a ExclusionsFactory that delegates to the default one and then and add custom exclusions: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( exclusionsFactory = { hprofParser - val defaultFactory = AndroidExcludedRefs . exclusionsFactory ( AndroidExcludedRefs . appDefaults ) val appDefaults = defaultFactory ( hprofParser ) val customExclusion = Exclusion ( type = StaticFieldExclusion ( com.thirdparty.SomeSingleton , sContext ), status = Exclusion . Status . WONT_FIX_LEAK , reason = SomeSingleton in library X has a static field leaking a context. ) appDefaults + customExclusion }) } } Identifying leaking instances and labeling instances class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val customLabeler : Labeler = { parser , node - listOf ( Heap dump object id is ${node.instance} ) } val labelers = AndroidLabelers . defaultAndroidLabelers ( this ) + customLabeler val customInspector : LeakInspector = { parser , node - with ( parser ) { if ( node . instance . objectRecord . isInstanceOf ( com.example.MySingleton )) { LeakNodeStatus . notLeaking ( MySingleton is a singleton ) } else LeakNodeStatus . unknown () } } val leakInspectors = AndroidLeakInspectors . defaultAndroidInspectors () + customInspector LeakCanary . config = LeakCanary . config . copy ( labelers = labelers , leakInspectors = leakInspectors ) } }","title":"Code recipes"},{"location":"recipes/#code-recipes","text":"If you think a recipe might be missing or you re not sure that what you re trying to achieve is possible with the current APIs, please file an issue . Your feedback help us make LeakCanary better for the entire community.","title":"Code Recipes"},{"location":"recipes/#configuring-leaksentry","text":"LeakSentry can be configured by replacing LeakSentry.config : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakSentry . config = LeakSentry . config . copy ( watchFragmentViews = false ) } }","title":"Configuring LeakSentry"},{"location":"recipes/#configuring-leakcanary","text":"LeakCanary can be configured by replacing LeakCanary.config : disableLeakCanaryButton . setOnClickListener { LeakCanary . config = LeakCanary . config . copy ( dumpHeap = false ) }","title":"Configuring LeakCanary"},{"location":"recipes/#watching-objects-with-a-lifecycle","text":"In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use LeakSentry.refWatcher to watch instances that should be garbage collected: class MyService : Service { // ... override fun onDestroy () { super . onDestroy () LeakSentry . refWatcher . watch ( this ) } }","title":"Watching objects with a lifecycle"},{"location":"recipes/#counting-retained-instances-in-production","text":"com.squareup.leakcanary:leakcanary-android should only be used in debug builds. It depends on com.squareup.leakcanary:leaksentry which you can use in production to track and count retained instances. In your build.gradle : dependencies { implementation com.squareup.leakcanary:leaksentry:2.0-alpha-2 } In your leak reporting code: val retainedInstanceCount = LeakSentry . refWatcher . retainedKeys . size","title":"Counting retained instances in production"},{"location":"recipes/#running-leakcanary-in-instrumentation-tests","text":"Add the leakcanary-android-instrumentation dependency to your instrumentation tests: androidTestImplementation com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion} Add the dedicated run listener to defaultConfig in your build.gradle : android { defaultConfig { // ... testInstrumentationRunner android.support.test.runner.AndroidJUnitRunner testInstrumentationRunnerArgument listener , leakcanary.FailTestOnLeakRunListener } } Run the instrumentation tests: ./gradlew leakcanary-sample:connectedCheck You can extend FailTestOnLeakRunListener to customize the behavior.","title":"Running LeakCanary in instrumentation tests"},{"location":"recipes/#icon-and-label","text":"The activity that displays leaks comes with a default icon and label, which you can change by providing R.mipmap.leak_canary_icon and R.string.leak_canary_display_activity_label in your app: res/ mipmap-hdpi/ leak_canary_icon.png mipmap-mdpi/ leak_canary_icon.png mipmap-xhdpi/ leak_canary_icon.png mipmap-xxhdpi/ leak_canary_icon.png mipmap-xxxhdpi/ leak_canary_icon.png mipmap-anydpi-v26/ leak_canary_icon.xml ?xml version= 1.0 encoding= utf-8 ? resources string name= leak_canary_display_activity_label MyLeaks /string /resources","title":"Icon and label"},{"location":"recipes/#uploading-to-a-server","text":"You can change the default behavior to upload the analysis result to a server of your choosing. Create a custom AnalysisResultListener that delegates to the default: class LeakUploader : AnalysisResultListener { override fun invoke ( application : Application , heapAnalysis : HeapAnalysis ) { TODO ( Upload heap analysis to server ) // Delegate to default behavior (notification and saving result) DefaultAnalysisResultListener ( application , heapAnalysis ) } } Set analysisResultListener on the LeakCanary config: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( analysisResultListener = LeakUploader ()) } }","title":"Uploading to a server"},{"location":"recipes/#identifying-3rd-party-leaks-as-wont-fix","text":"Set exclusionsFactory on the LeakCanary config to a ExclusionsFactory that delegates to the default one and then and add custom exclusions: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( exclusionsFactory = { hprofParser - val defaultFactory = AndroidExcludedRefs . exclusionsFactory ( AndroidExcludedRefs . appDefaults ) val appDefaults = defaultFactory ( hprofParser ) val customExclusion = Exclusion ( type = StaticFieldExclusion ( com.thirdparty.SomeSingleton , sContext ), status = Exclusion . Status . WONT_FIX_LEAK , reason = SomeSingleton in library X has a static field leaking a context. ) appDefaults + customExclusion }) } }","title":"Identifying 3rd party leaks as \"won't fix\""},{"location":"recipes/#identifying-leaking-instances-and-labeling-instances","text":"class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val customLabeler : Labeler = { parser , node - listOf ( Heap dump object id is ${node.instance} ) } val labelers = AndroidLabelers . defaultAndroidLabelers ( this ) + customLabeler val customInspector : LeakInspector = { parser , node - with ( parser ) { if ( node . instance . objectRecord . isInstanceOf ( com.example.MySingleton )) { LeakNodeStatus . notLeaking ( MySingleton is a singleton ) } else LeakNodeStatus . unknown () } } val leakInspectors = AndroidLeakInspectors . defaultAndroidInspectors () + customInspector LeakCanary . config = LeakCanary . config . copy ( labelers = labelers , leakInspectors = leakInspectors ) } }","title":"Identifying leaking instances and labeling instances"},{"location":"recorded-presentations/","text":"LeakCanary 2: Leaner, Better, Faster, Kotliner! LeakCanary, then what? Nuking Nasty Memory Leaks Memory Leak Hunt , a live investigation. Installing LeakCanary (LeakCanary 1.5) How to use LeakCanary Your presentation should be here, please update this list! Any technical level welcome.","title":"Recorded Presentations"},{"location":"support/","text":"LeakCanary Support If you re looking for support for LeakCanary: Learn the Fundamentals Try the code recipes Read the FAQ Watch recorded presentations Read blog articles Check out the StackOverflow LeakCanary tag and ask a question Feel free to edit this file to add links to online communities that can help developers investigate LeakCanary leaks.","title":"Support"},{"location":"support/#leakcanary-support","text":"If you re looking for support for LeakCanary: Learn the Fundamentals Try the code recipes Read the FAQ Watch recorded presentations Read blog articles Check out the StackOverflow LeakCanary tag and ask a question Feel free to edit this file to add links to online communities that can help developers investigate LeakCanary leaks.","title":"LeakCanary Support"},{"location":"upgrading-to-leakcanary-2.0/","text":"Dependencies Before dependencies { debugImplementation com.squareup.leakcanary:leakcanary-android:1.6.3 releaseImplementation com.squareup.leakcanary:leakcanary-android-no-op:1.6.3 // Optional, if you use support library fragments: debugImplementation com.squareup.leakcanary:leakcanary-support-fragment:1.6.3 } Now dependencies { debugImplementation com.squareup.leakcanary:leakcanary-android:2.0-alpha-2 } Worth noting The leakcanary-android-no-op artifact is gone. If you have compile errors, see below. Question : if there s no no-op anymore, how do I ensure none of this runs during release builds? Answer : as long as you add leakcanary-android as debugImplementation , there won t be any code referencing LeakCanary in your release builds. LeakCanary now depends on AndroidX instead of the support library. Detection of AndroidX fragments is now automatic if you have the AndroidX fragments dependency. Default setup code Before public class ExampleApplication extends Application { @Override public void onCreate () { super . onCreate (); if ( LeakCanary . isInAnalyzerProcess ( this )) { // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return ; } LeakCanary . install ( this ); // Normal app init code... } } Now There is no more code for default setup. Worth noting LeakCanary auto installs itself LeakCanary analysis now runs in the main process so there is no need to call LeakCanary.isInAnalyzerProcess() . Retrieve the RefWatcher Before val refWatcher = LeakCanary . installedRefWatcher () Now val refWatcher = LeakSentry . refWatcher Compile errors because RefWatcher is used in release code If you were using RefWatcher in non debug code, you now get a compile error because the no-op artifact is gone. RefWatcher now lives in the leaksentry artifact, which is suitable for production. You have two options: Option 1: Add leaksentry to release builds. dependencies { implementation com.squareup.leakcanary:leaksentry:2.0-alpha-2 } It will automatically keep weak references on activities, fragments, and any instance you pass to RefWatcher . It will not trigger heap dumps or anything else that LeakCanary does. It s very little code and should have a no impact on your release app. You can use it to count how many instances are retained, for instance to add metadata to OutOfMemoryError crashes: val retainedInstanceCount = LeakSentry . refWatcher . retainedKeys . size Option 2: Make your own RefWatcher interface // In shared code interface MaybeRefWatcher { fun watch ( watchedReference : Any ) object None : MaybeRefWatcher { override fun watch ( watchedReference : Any ) { } } } // In debug code class RealRefWatcher : MaybeRefWatcher { override fun watch ( watchedReference : Any ) { LeakSentry . refWatcher . watch ( watchedReference ) } } Use MaybeRefWatcher.None in release code and RealRefWatcher in debug code. Configuring LeakCanary Before public class DebugExampleApplication extends ExampleApplication { @Override protected void installLeakCanary () { RefWatcher refWatcher = LeakCanary . refWatcher ( this ) . watchActivities ( false ) . buildAndInstall (); } } Now LeakSentry is in charge of detecting memory leaks. Its configuration can be updated at any time by replacing LeakSentry.config : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakSentry . config = LeakSentry . config . copy ( watchFragmentViews = false ) } } LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing LeakCanary.config : disableLeakCanaryButton . setOnClickListener { LeakCanary . config = LeakCanary . config . copy ( dumpHeap = false ) } Running LeakCanary in instrumentation tests Before In your build.gradle file: dependencies { androidTestImplementation com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion} } android { defaultConfig { // ... testInstrumentationRunner android.support.test.runner.AndroidJUnitRunner testInstrumentationRunnerArgument listener , com.squareup.leakcanary.FailTestOnLeakRunListener } } In your test Application class: public class InstrumentationTestExampleApplication extends DebugExampleApplication { @Override protected void installLeakCanary () { InstrumentationLeakDetector . instrumentationRefWatcher ( this ) . buildAndInstall (); } } Now In your build.gradle file: dependencies { androidTestImplementation com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion} } android { defaultConfig { // ... testInstrumentationRunner android.support.test.runner.AndroidJUnitRunner testInstrumentationRunnerArgument listener , leakcanary.FailTestOnLeakRunListener } } No code is necessary. Public API packages Before All public APIs were in com.squareup.leakcanary.* Now All public APIs are in leakcanary.*","title":"Upgrading to LeakCanary 2"},{"location":"upgrading-to-leakcanary-2.0/#dependencies","text":"","title":"Dependencies"},{"location":"upgrading-to-leakcanary-2.0/#before","text":"dependencies { debugImplementation com.squareup.leakcanary:leakcanary-android:1.6.3 releaseImplementation com.squareup.leakcanary:leakcanary-android-no-op:1.6.3 // Optional, if you use support library fragments: debugImplementation com.squareup.leakcanary:leakcanary-support-fragment:1.6.3 }","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now","text":"dependencies { debugImplementation com.squareup.leakcanary:leakcanary-android:2.0-alpha-2 }","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#worth-noting","text":"The leakcanary-android-no-op artifact is gone. If you have compile errors, see below. Question : if there s no no-op anymore, how do I ensure none of this runs during release builds? Answer : as long as you add leakcanary-android as debugImplementation , there won t be any code referencing LeakCanary in your release builds. LeakCanary now depends on AndroidX instead of the support library. Detection of AndroidX fragments is now automatic if you have the AndroidX fragments dependency.","title":"Worth noting"},{"location":"upgrading-to-leakcanary-2.0/#default-setup-code","text":"","title":"Default setup code"},{"location":"upgrading-to-leakcanary-2.0/#before_1","text":"public class ExampleApplication extends Application { @Override public void onCreate () { super . onCreate (); if ( LeakCanary . isInAnalyzerProcess ( this )) { // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return ; } LeakCanary . install ( this ); // Normal app init code... } }","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_1","text":"There is no more code for default setup.","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#worth-noting_1","text":"LeakCanary auto installs itself LeakCanary analysis now runs in the main process so there is no need to call LeakCanary.isInAnalyzerProcess() .","title":"Worth noting"},{"location":"upgrading-to-leakcanary-2.0/#retrieve-the-refwatcher","text":"","title":"Retrieve the RefWatcher"},{"location":"upgrading-to-leakcanary-2.0/#before_2","text":"val refWatcher = LeakCanary . installedRefWatcher ()","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_2","text":"val refWatcher = LeakSentry . refWatcher","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#compile-errors-because-refwatcher-is-used-in-release-code","text":"If you were using RefWatcher in non debug code, you now get a compile error because the no-op artifact is gone. RefWatcher now lives in the leaksentry artifact, which is suitable for production. You have two options:","title":"Compile errors because RefWatcher is used in release code"},{"location":"upgrading-to-leakcanary-2.0/#option-1-add-leaksentry-to-release-builds","text":"dependencies { implementation com.squareup.leakcanary:leaksentry:2.0-alpha-2 } It will automatically keep weak references on activities, fragments, and any instance you pass to RefWatcher . It will not trigger heap dumps or anything else that LeakCanary does. It s very little code and should have a no impact on your release app. You can use it to count how many instances are retained, for instance to add metadata to OutOfMemoryError crashes: val retainedInstanceCount = LeakSentry . refWatcher . retainedKeys . size","title":"Option 1: Add leaksentry to release builds."},{"location":"upgrading-to-leakcanary-2.0/#option-2-make-your-own-refwatcher-interface","text":"// In shared code interface MaybeRefWatcher { fun watch ( watchedReference : Any ) object None : MaybeRefWatcher { override fun watch ( watchedReference : Any ) { } } } // In debug code class RealRefWatcher : MaybeRefWatcher { override fun watch ( watchedReference : Any ) { LeakSentry . refWatcher . watch ( watchedReference ) } } Use MaybeRefWatcher.None in release code and RealRefWatcher in debug code.","title":"Option 2: Make your own RefWatcher interface"},{"location":"upgrading-to-leakcanary-2.0/#configuring-leakcanary","text":"","title":"Configuring LeakCanary"},{"location":"upgrading-to-leakcanary-2.0/#before_3","text":"public class DebugExampleApplication extends ExampleApplication { @Override protected void installLeakCanary () { RefWatcher refWatcher = LeakCanary . refWatcher ( this ) . watchActivities ( false ) . buildAndInstall (); } }","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_3","text":"LeakSentry is in charge of detecting memory leaks. Its configuration can be updated at any time by replacing LeakSentry.config : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakSentry . config = LeakSentry . config . copy ( watchFragmentViews = false ) } } LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing LeakCanary.config : disableLeakCanaryButton . setOnClickListener { LeakCanary . config = LeakCanary . config . copy ( dumpHeap = false ) }","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#running-leakcanary-in-instrumentation-tests","text":"","title":"Running LeakCanary in instrumentation tests"},{"location":"upgrading-to-leakcanary-2.0/#before_4","text":"In your build.gradle file: dependencies { androidTestImplementation com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion} } android { defaultConfig { // ... testInstrumentationRunner android.support.test.runner.AndroidJUnitRunner testInstrumentationRunnerArgument listener , com.squareup.leakcanary.FailTestOnLeakRunListener } } In your test Application class: public class InstrumentationTestExampleApplication extends DebugExampleApplication { @Override protected void installLeakCanary () { InstrumentationLeakDetector . instrumentationRefWatcher ( this ) . buildAndInstall (); } }","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_4","text":"In your build.gradle file: dependencies { androidTestImplementation com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion} } android { defaultConfig { // ... testInstrumentationRunner android.support.test.runner.AndroidJUnitRunner testInstrumentationRunnerArgument listener , leakcanary.FailTestOnLeakRunListener } } No code is necessary.","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#public-api-packages","text":"","title":"Public API packages"},{"location":"upgrading-to-leakcanary-2.0/#before_5","text":"All public APIs were in com.squareup.leakcanary.*","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_5","text":"All public APIs are in leakcanary.*","title":"Now"}]}